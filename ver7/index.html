<!doctype html>
<html lang="zh-Hant">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <title>Mini RTS - v7 (Hunters + Wildlife AI + HP/Flee + Leash)</title>
  <style>
    body{margin:0;font-family:system-ui,-apple-system,"Segoe UI",Arial,"Noto Sans TC",sans-serif;}
    .wrap{display:grid;grid-template-columns:auto 320px 520px;height:100vh;}
    canvas{background:#111;image-rendering:pixelated;}
    .panel{background:#0b0b0b;color:#ddd;padding:12px;overflow:auto;border-left:1px solid #222;}
    .midpanel{background:#0b0b0b;color:#ddd;padding:12px;overflow:auto;border-left:1px solid #222;}
    .panel h2{margin:0 0 8px;font-size:16px;}
    .hint{font-size:12px;color:#aaa;margin:10px 0;line-height:1.45;}
    .row{display:flex;gap:8px;flex-wrap:wrap;align-items:center;}
    .row label{font-size:12px;color:#bbb;display:flex;gap:6px;align-items:center;}
    .row input{width:96px;background:#0f0f0f;color:#eee;border:1px solid #333;padding:6px 8px;border-radius:6px;}
    button{background:#222;color:#eee;border:1px solid #333;padding:6px 10px;border-radius:6px;cursor:pointer;}
    button:hover{background:#2a2a2a;}
    .tag{display:inline-block;padding:1px 6px;border:1px solid #333;border-radius:999px;font-size:11px;color:#bbb;}
    .divider{height:1px;background:#1f1f1f;margin:10px 0;}
    .kv{font-size:13px;line-height:1.45;}
    .kv b{color:#fff;}
    .pill{display:inline-block;padding:2px 8px;border:1px solid #333;border-radius:999px;font-size:12px;color:#ddd;margin-right:6px;margin-bottom:6px;}
    .log{font-family:ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,"Liberation Mono",monospace;font-size:12px;white-space:pre-wrap;background:#070707;border:1px solid #222;padding:8px;border-radius:6px;}
    .hpall{font-family:ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,"Liberation Mono",monospace;font-size:11px;white-space:pre-wrap;background:#090909;border:1px solid #222;padding:8px;border-radius:6px;height:calc(100vh - 120px);overflow:auto;}
    .small{font-size:12px;color:#aaa;margin:8px 0 6px;}
  </style>
</head>
<body>
<div class="wrap">
  <canvas id="c"></canvas>
  <div class="midpanel">
    <h2>單位血量（即時）</h2>
    <div class="hpall" id="hpAll"></div>
  </div>
  <div class="panel">
    <h2>Mini RTS v7：獵人 + 野生動物 + 血量/逃跑</h2>
    <div class="hint">
      玩法：調參數 → 生成地圖 → 開始。點選資源可設定偏好目標。<br/>
      <b>獵人</b>：追擊野生動物，擊殺後採集肉並回倉庫交付。<br/>
      <b>野生動物</b>：在家附近徘徊，被攻擊會追擊但不超出 leash。<br/>
      <b>血量逃跑</b>：工人/獵人 HP < 20% 會逃到倉庫旁安全區。<br/>
      <b>獵人回血</b>：在 parking ring 每秒回 1 HP，消耗 1 食物；回到 60% HP 繼續工作。
    </div>

    <div class="row" style="margin:6px 0 8px;">
      <label>伐木工 <input id="inpLumber" type="number" min="0" max="900" value="60"/></label>
      <label>採礦工 <input id="inpMiner" type="number" min="0" max="900" value="50"/></label>
      <label>獵人 <input id="inpHunter" type="number" min="0" max="900" value="30"/></label>
      <label>斥侯 <input id="inpScout" type="number" min="0" max="200" value="6"/></label>
    </div>

    <div class="row" style="margin:0 0 8px;">
      <label>伐木HP <input id="inpHPLumber" type="number" min="1" max="200" value="10"/></label>
      <label>採礦HP <input id="inpHPMiner" type="number" min="1" max="200" value="10"/></label>
      <label>獵人HP <input id="inpHPHunter" type="number" min="1" max="200" value="12"/></label>
      <label>斥侯HP <input id="inpHPScout" type="number" min="1" max="200" value="8"/></label>
      <label>動物HP <input id="inpHPAnimal" type="number" min="1" max="200" value="18"/></label>
    </div>

    <div class="row" style="margin:0 0 8px;">
      <label>樹木數量 <input id="inpTrees" type="number" min="0" max="9000" value="1200"/></label>
      <label>礦石數量 <input id="inpRocks" type="number" min="0" max="6000" value="750"/></label>
      <label>野生動物 <input id="inpAnimals" type="number" min="0" max="3000" value="220"/></label>
      <label>障礙(%) <input id="inpObs" type="number" min="0" max="40" value="10"/></label>
    </div>

    <div class="row" style="margin:0 0 8px;">
      <label>工人視野 <input id="inpVisW" type="number" min="2" max="24" value="7"/></label>
      <label>斥侯視野 <input id="inpVisS" type="number" min="4" max="36" value="13"/></label>
      <label>格像素 <input id="inpTile" type="number" min="4" max="12" value="7"/></label>
    </div>

    <div class="row" style="margin:0 0 8px;">
      <label>A* / tick <input id="inpAstarBudget" type="number" min="1" max="80" value="12"/></label>
      <label>目標抽樣K <input id="inpSampleK" type="number" min="5" max="200" value="45"/></label>
      <label>Tick Hz <input id="inpHz" type="number" min="5" max="60" value="20"/></label>
    </div>

    <div class="row" style="margin-bottom:6px;">
      <button id="gen">生成地圖</button>
      <button id="start">開始</button>
      <button id="pause">暫停</button>
      <button id="step">單步</button>
      <button id="clearlog">清除訊息</button>
      <span class="tag" id="statusTag">READY</span>
    </div>

    <div class="kv" id="info"></div>
    <div class="small">事件訊息</div>
    <div class="log" id="log"></div>
  </div>
</div>

<script>
(() => {
  const W=100, H=100, N=W*H;
  const Tile = { Empty:0, Block:1, Storage:2 };
  const ResT = { None:0, Tree:1, Rock:2, Meat:3 }; // Meat = carcass food resource

  // Gather / Combat constants
  const WORKER_CARRY_CAP=10;

  const CHOP_RATE=1, MINE_RATE=1, MEAT_RATE=1;
  const TREE_MIN=18, TREE_MAX=55;
  const ROCK_MIN=25, ROCK_MAX=70;
  const MEAT_MIN=14, MEAT_MAX=35;

  const ATK_DAMAGE=1;              // fixed
  const ATK_INTERVAL=1.0;          // seconds
  const FLEE_HP_FRAC=0.20;         // 20%
  const FLEE_HIT_FRAC=0.60;        // flee if recently hit and below this
  const HUNTER_RESUME_HP_FRAC=0.60;// 60%
  const HUNTER_HEAL_INTERVAL=1.0;  // seconds per heal

  // Animal AI
  let ANIMAL_HP=18;
  const ANIMAL_MOVE_INTERVAL=2.0; // seconds (half hunter speed)
  const ANIMAL_WANDER_R=6;         // from home
  const ANIMAL_LEASH_R=12;         // chase limit from home
  const ANIMAL_MIN_DIST=4;         // spawn separation (Chebyshev)
  const ANIMAL_THINK_MIN=0.7;      // seconds
  const ANIMAL_THINK_MAX=1.6;

  // Storage traffic control (from v6)
  const STORAGE_RING_R = 1;
  const PARK_RING_R = 2;
  const PUSH_STUCK_TICKS = 6;
  const PUSH_NEAR_STORAGE_R = 5;

  const canvas=document.getElementById("c");
  const ctx=canvas.getContext("2d");
  ctx.imageSmoothingEnabled=false;

  const logEl=document.getElementById("log");
  const infoEl=document.getElementById("info");
  const hpAllEl=document.getElementById("hpAll");
  const statusTag=document.getElementById("statusTag");

  const inpLumber=document.getElementById("inpLumber");
  const inpMiner=document.getElementById("inpMiner");
  const inpHunter=document.getElementById("inpHunter");
  const inpScout=document.getElementById("inpScout");
  const inpHPLumber=document.getElementById("inpHPLumber");
  const inpHPMiner=document.getElementById("inpHPMiner");
  const inpHPHunter=document.getElementById("inpHPHunter");
  const inpHPScout=document.getElementById("inpHPScout");
  const inpHPAnimal=document.getElementById("inpHPAnimal");
  const inpTrees=document.getElementById("inpTrees");
  const inpRocks=document.getElementById("inpRocks");
  const inpAnimals=document.getElementById("inpAnimals");
  const inpObs=document.getElementById("inpObs");
  const inpVisW=document.getElementById("inpVisW");
  const inpVisS=document.getElementById("inpVisS");
  const inpTile=document.getElementById("inpTile");
  const inpAstarBudget=document.getElementById("inpAstarBudget");
  const inpSampleK=document.getElementById("inpSampleK");
  const inpHz=document.getElementById("inpHz");

  const btnGen=document.getElementById("gen");
  const btnStart=document.getElementById("start");
  const btnPause=document.getElementById("pause");
  const btnStep=document.getElementById("step");
  const btnClear=document.getElementById("clearlog");
  btnClear.onclick=()=> (logEl.textContent="");

  function clampInt(v,lo,hi,f){ const n=Number(v); if(!Number.isFinite(n)) return f; return Math.max(lo,Math.min(hi,Math.floor(n))); }
  function nowStr(){ const t=new Date(); return `[${String(t.getHours()).padStart(2,"0")}:${String(t.getMinutes()).padStart(2,"0")}:${String(t.getSeconds()).padStart(2,"0")}]`; }
  function log(msg){ logEl.textContent = `${nowStr()} ${msg}\n` + logEl.textContent; }
  window.onerror=(msg, src, line, col)=>{
    log(`JS Error: ${msg} @${line}:${col}`);
  };

  const idx=(x,y)=> y*W+x;
  const xOf=(i)=> i%W;
  const yOf=(i)=> (i/W)|0;
  const inBounds=(x,y)=> x>=0&&x<W&&y>=0&&y<H;
  const manhattan=(ax,ay,bx,by)=> Math.abs(ax-bx)+Math.abs(ay-by);
  const cheb=(ax,ay,bx,by)=> Math.max(Math.abs(ax-bx), Math.abs(ay-by));

  let TILEPX=7;
  let TICK_HZ=20;
  let STEP_TIME=1/TICK_HZ;
  let ASTAR_BUDGET=12;
  let SAMPLE_K=45;

  let grid, occupied, explored, visible, visiblePrev;
  let resType, resIdAt;
  let trees=[], rocks=[], meats=[]; // meats are carcass resources
  let animals=[];                   // wildlife agents
  let knownTreeIds=[], knownRockIds=[], knownMeatIds=[];

  let storage={x:50,y:50,wood:0,ore:0,food:0};

  let units=[], workers=[], scouts=[];
  let preferred={type:null,id:null}; // type: "tree"/"rock"/"meat"

  // Rings & reservations
  let dropTiles=[], parkTiles=[];
  let dropReservedBy, parkReservedBy;

  // --- layered render ---
  let baseLayer,fogLayer,baseCtx,fogCtx;
  function resizeCanvases(){
    canvas.width=W*TILEPX; canvas.height=H*TILEPX;
    baseLayer=document.createElement("canvas");
    fogLayer=document.createElement("canvas");
    baseLayer.width=fogLayer.width=canvas.width;
    baseLayer.height=fogLayer.height=canvas.height;
    baseCtx=baseLayer.getContext("2d");
    fogCtx=fogLayer.getContext("2d");
    baseCtx.imageSmoothingEnabled=false;
    fogCtx.imageSmoothingEnabled=false;
  }
  function clearCanvas(c){ c.clearRect(0,0,c.canvas.width,c.canvas.height); }

  function distToStorage(x,y){ return Math.max(Math.abs(x-storage.x), Math.abs(y-storage.y)); }
  function isAdjacentToStorage(x,y){
    return Math.abs(x-storage.x)<=1 && Math.abs(y-storage.y)<=1 && !(x===storage.x && y===storage.y);
  }

  function buildRings(){
    dropTiles=[]; parkTiles=[];
    for(let dy=-PARK_RING_R; dy<=PARK_RING_R; dy++){
      for(let dx=-PARK_RING_R; dx<=PARK_RING_R; dx++){
        const x=storage.x+dx, y=storage.y+dy;
        if(!inBounds(x,y)) continue;
        if(dx===0 && dy===0) continue;

        const r = Math.max(Math.abs(dx), Math.abs(dy));
        const i=idx(x,y);

        if(grid[i]===Tile.Block) continue;
        if(resType[i]!==ResT.None) continue;

        if(r===STORAGE_RING_R) dropTiles.push(i);
        else if(r===PARK_RING_R) parkTiles.push(i);
      }
    }
  }

  function drawStorageAndRings(){
    baseCtx.fillStyle="rgb(220,200,60)";
    baseCtx.fillRect(storage.x*TILEPX, storage.y*TILEPX, TILEPX, TILEPX);

    baseCtx.fillStyle="rgba(220,200,60,0.22)";
    for(const ti of dropTiles){
      baseCtx.fillRect(xOf(ti)*TILEPX, yOf(ti)*TILEPX, TILEPX, TILEPX);
    }
    baseCtx.fillStyle="rgba(120,190,255,0.10)";
    for(const ti of parkTiles){
      baseCtx.fillRect(xOf(ti)*TILEPX, yOf(ti)*TILEPX, TILEPX, TILEPX);
    }
  }
  function drawTreeTile(x,y){ baseCtx.fillStyle="rgb(0,120,0)"; baseCtx.fillRect(x*TILEPX,y*TILEPX,TILEPX,TILEPX); }
  function drawRockTile(x,y){ baseCtx.fillStyle="rgb(90,40,140)"; baseCtx.fillRect(x*TILEPX,y*TILEPX,TILEPX,TILEPX); }
  function drawMeatTile(x,y){ baseCtx.fillStyle="rgb(170,90,60)"; baseCtx.fillRect(x*TILEPX,y*TILEPX,TILEPX,TILEPX); }

  function drawBaseAll(){
    clearCanvas(baseCtx);
    baseCtx.fillStyle="#111";
    baseCtx.fillRect(0,0,baseLayer.width,baseLayer.height);

    baseCtx.fillStyle="rgb(70,70,70)";
    for(let i=0;i<N;i++){
      if(grid[i]===Tile.Block){
        baseCtx.fillRect(xOf(i)*TILEPX, yOf(i)*TILEPX, TILEPX, TILEPX);
      }
    }
    drawStorageAndRings();
  }

  function eraseTileToBackground(i){
    const x=xOf(i), y=yOf(i);
    baseCtx.fillStyle="#111";
    baseCtx.fillRect(x*TILEPX,y*TILEPX,TILEPX,TILEPX);
    if(grid[i]===Tile.Block){
      baseCtx.fillStyle="rgb(70,70,70)";
      baseCtx.fillRect(x*TILEPX,y*TILEPX,TILEPX,TILEPX);
    } else if(grid[i]===Tile.Storage){
      drawStorageAndRings();
    } else {
      const r=distToStorage(x,y);
      if(r===STORAGE_RING_R){
        baseCtx.fillStyle="rgba(220,200,60,0.22)";
        baseCtx.fillRect(x*TILEPX,y*TILEPX,TILEPX,TILEPX);
      } else if(r===PARK_RING_R){
        baseCtx.fillStyle="rgba(120,190,255,0.10)";
        baseCtx.fillRect(x*TILEPX,y*TILEPX,TILEPX,TILEPX);
      }
    }
  }

  // --- fog ---
  function drawFogTile(i){
    const x=xOf(i), y=yOf(i);
    if(!explored[i]){
      fogCtx.fillStyle="rgb(0,0,0)";
      fogCtx.fillRect(x*TILEPX,y*TILEPX,TILEPX,TILEPX);
      return;
    }
    if(!visible[i]){
      fogCtx.fillStyle="rgba(0,0,0,0.55)";
      fogCtx.fillRect(x*TILEPX,y*TILEPX,TILEPX,TILEPX);
      return;
    }
    fogCtx.clearRect(x*TILEPX,y*TILEPX,TILEPX,TILEPX);
  }
  function drawFogAll(){
    clearCanvas(fogCtx);
    for(let i=0;i<N;i++) drawFogTile(i);
  }

  let visOffsetsWorker=[], visOffsetsScout=[];
  function buildOffsets(r){
    const out=[];
    for(let dy=-r; dy<=r; dy++){
      for(let dx=-r; dx<=r; dx++){
        if(dx*dx+dy*dy<=r*r) out.push({dx,dy});
      }
    }
    return out;
  }
  function clearFog(){
    explored=new Uint8Array(N);
    visible=new Uint8Array(N);
    visiblePrev=new Uint8Array(N);
    knownTreeIds=[];
    knownRockIds=[];
    knownMeatIds=[];
  }

  function discoverResourceAtTile(i){
    const rt=resType[i];
    if(rt===ResT.Tree){
      const id=resIdAt[i];
      if(id>=0) knownTreeIds.push(id);
      drawTreeTile(xOf(i), yOf(i));
    } else if(rt===ResT.Rock){
      const id=resIdAt[i];
      if(id>=0) knownRockIds.push(id);
      drawRockTile(xOf(i), yOf(i));
    } else if(rt===ResT.Meat){
      const id=resIdAt[i];
      if(id>=0) knownMeatIds.push(id);
      drawMeatTile(xOf(i), yOf(i));
    }
  }

  function updateVisibilityAndFogLayers(){
    visible.fill(0);
    for(const u of units){
      const offsets = (u.role==="scout") ? visOffsetsScout : visOffsetsWorker;
      const ux=u.x, uy=u.y;
      for(const o of offsets){
        const x=ux+o.dx, y=uy+o.dy;
        if(!inBounds(x,y)) continue;
        visible[idx(x,y)]=1;
      }
    }
    // also animal vision? keep simple: animals don't reveal fog
    const changed=[];
    const newly=[];
    for(let i=0;i<N;i++){
      const v=visible[i], pv=visiblePrev[i];
      if(v!==pv) changed.push(i);
      if(v===1 && explored[i]===0){
        explored[i]=1;
        newly.push(i);
      }
    }
    for(const i of changed) visiblePrev[i]=visible[i];
    for(const i of newly){
      if(resType[i]!==ResT.None) discoverResourceAtTile(i);
      drawFogTile(i);
    }
    for(const i of changed) drawFogTile(i);
  }

  // --- walkability ---
  function isWalkableTile(i){
    if(grid[i]===Tile.Block) return false;
    if(resType[i]!==ResT.None) return false;
    return true;
  }
  function canMoveDiag(fromI,toI){
    const fx=xOf(fromI), fy=yOf(fromI);
    const tx=xOf(toI), ty=yOf(toI);
    const dx=tx-fx, dy=ty-fy;
    if(Math.abs(dx)===1 && Math.abs(dy)===1){
      const i1=idx(fx+dx, fy);
      const i2=idx(fx, fy+dy);
      if(!isWalkableTile(i1) || !isWalkableTile(i2)) return false;
    }
    return true;
  }

  // --- A* ---
  const DIRS8=[
    {dx:1,dy:0,c:1},{dx:-1,dy:0,c:1},{dx:0,dy:1,c:1},{dx:0,dy:-1,c:1},
    {dx:1,dy:1,c:Math.SQRT2},{dx:1,dy:-1,c:Math.SQRT2},{dx:-1,dy:1,c:Math.SQRT2},{dx:-1,dy:-1,c:Math.SQRT2},
  ];
  function octileH(ax,ay,bx,by){
    const dx=Math.abs(ax-bx), dy=Math.abs(ay-by);
    const F=Math.SQRT2-1;
    return (dx<dy)?F*dx+dy:F*dy+dx;
  }
  class MinHeap{
    constructor(){ this.nodes=[]; this.fs=[]; }
    size(){ return this.nodes.length; }
    push(node,f){
      const a=this.nodes, b=this.fs;
      let i=a.length;
      a.push(node); b.push(f);
      while(i>0){
        const p=(i-1)>>1;
        if(b[p]<=f) break;
        a[i]=a[p]; b[i]=b[p];
        i=p;
      }
      a[i]=node; b[i]=f;
    }
    pop(){
      const a=this.nodes, b=this.fs;
      const n=a.length;
      if(!n) return null;
      const out=a[0];
      const lastN=a.pop();
      const lastF=b.pop();
      if(n>1){
        let i=0;
        while(true){
          let l=i*2+1, r=l+1;
          if(l>=a.length) break;
          let s=l;
          if(r<a.length && b[r]<b[l]) s=r;
          if(b[s]>=lastF) break;
          a[i]=a[s]; b[i]=b[s];
          i=s;
        }
        a[i]=lastN; b[i]=lastF;
      }
      return out;
    }
  }
  let gScore,parent,seenStamp,closedStamp,stampCounter;
  function initAstarArrays(){
    gScore=new Float32Array(N);
    parent=new Int32Array(N);
    seenStamp=new Int32Array(N);
    closedStamp=new Int32Array(N);
    stampCounter=1;
  }
  function astar(startI,goalI,avoidOccupied=true){
    const stamp=stampCounter++;
    if(stampCounter>1e9){ seenStamp.fill(0); closedStamp.fill(0); stampCounter=1; }

    const open=new MinHeap();
    const sx=xOf(startI), sy=yOf(startI), gx=xOf(goalI), gy=yOf(goalI);

    seenStamp[startI]=stamp;
    gScore[startI]=0;
    parent[startI]=-1;
    open.push(startI, octileH(sx,sy,gx,gy));

    while(open.size()){
      const cur=open.pop();
      if(cur===goalI){
        const path=[];
        let p=cur;
        while(p!==-1 && p!==startI){
          path.push(p);
          p=parent[p];
        }
        path.reverse();
        return path;
      }
      closedStamp[cur]=stamp;
      const baseG=gScore[cur];
      const cx=xOf(cur), cy=yOf(cur);

      for(const d of DIRS8){
        const nx=cx+d.dx, ny=cy+d.dy;
        if(!inBounds(nx,ny)) continue;
        const ni=idx(nx,ny);

        if(!isWalkableTile(ni) && ni!==goalI) continue;
        if(!canMoveDiag(cur,ni)) continue;

        if(avoidOccupied){
          const occ=occupied[ni];
          if(occ!==-1 && ni!==goalI) continue;
        }
        if(closedStamp[ni]===stamp) continue;

        const tentative=baseG+d.c;
        if(seenStamp[ni]!==stamp || tentative<gScore[ni]){
          seenStamp[ni]=stamp;
          gScore[ni]=tentative;
          parent[ni]=cur;
          open.push(ni, tentative + octileH(nx,ny,gx,gy));
        }
      }
    }
    return null;
  }

  // --- path request queue ---
  let pathQueue=[];
  function requestPath(unitId,goalI){
    const u=units[unitId];
    if(!u || u.waitingPath) return;
    u.waitingPath=true;
    pathQueue.push({unitId, startI:idx(u.x,u.y), goalI});
  }
  function processPathQueue(){
    let done=0;
    while(done<ASTAR_BUDGET && pathQueue.length){
      const job=pathQueue.shift();
      const u=units[job.unitId];
      if(!u) continue;
      u.waitingPath=false;

      const path=astar(job.startI, job.goalI, true);
      if(!path){
        u.path=[];
        u.state="Idle";
        u.target=null;
        u.intent=null;
        u.stuckTicks=0;
        // release reservations
        if(u.dropTileI!=null){ releaseReservation(u.id, dropTiles, dropReservedBy); u.dropTileI=null; }
        if(u.parkTileI!=null){ releaseReservation(u.id, parkTiles, parkReservedBy); u.parkTileI=null; }
      } else {
        u.path=path;
        u.state=u.intent==="ToStorage" ? "ToStorage" : (u.intent==="ToPark" ? "ToPark" : "Move");
        u.stuckTicks=0;
      }
      done++;
    }
  }

  // --- occupancy ---
  function rebuildOccupancy(){
    occupied.fill(-1);
    for(const u of units) occupied[idx(u.x,u.y)]=u.id;
    // animals do NOT occupy the same grid as units in occupied[]; we keep separate occupancy to allow "melee"
    // but animals still avoid standing on occupied tiles.
  }

  // --- reservations ---
  function reserveTileFromList(unitId, list, reservedBy){
    const u=units[unitId];
    let best=-1, bestD=1e9;
    for(const ti of list){
      const r=reservedBy[ti];
      if(r!==-1 && r!==unitId) continue;
      const occ=occupied[ti];
      if(occ!==-1 && occ!==unitId) continue;
      // also avoid animals currently standing there
      if(animalAt[ti]!==-1) continue;
      const d = Math.abs(xOf(ti)-u.x)+Math.abs(yOf(ti)-u.y);
      if(d<bestD){ bestD=d; best=ti; }
    }
    if(best!==-1){
      reservedBy[best]=unitId;
      return best;
    }
    return -1;
  }
  function releaseReservation(unitId, list, reservedBy){
    for(const ti of list){
      if(reservedBy[ti]===unitId) reservedBy[ti]=-1;
    }
  }

  // --- yield / push (units only) ---
  function isPushableUnit(v){
    return (v.state==="Idle" || v.state==="QueueStorage" || v.state==="Dropoff" || v.state==="Parked");
  }
  function findFreeNeighborForUnit(v, avoidI){
    let best=-1, bestScore=1e9;
    for(const d of DIRS8){
      const nx=v.x+d.dx, ny=v.y+d.dy;
      if(!inBounds(nx,ny)) continue;
      const ni=idx(nx,ny);
      if(ni===avoidI) continue;
      if(!isWalkableTile(ni)) continue;
      if(dropReservedBy[ni]!==-1 && dropReservedBy[ni]!==v.id) continue;
      if(parkReservedBy[ni]!==-1 && parkReservedBy[ni]!==v.id) continue;
      if(occupied[ni]!==-1) continue;
      if(animalAt[ni]!==-1) continue;

      const score = distToStorage(nx,ny) + Math.abs(nx-v.x)+Math.abs(ny-v.y)*0.2;
      if(score<bestScore){ bestScore=score; best=ni; }
    }
    return best;
  }
  function tryYieldOrPush(u, nextI){
    const vId = occupied[nextI];
    if(vId===-1) return false;
    const v = units[vId];
    if(!v) return false;
    if(distToStorage(u.x,u.y) > PUSH_NEAR_STORAGE_R) return false;

    if(v.path && v.path.length && v.path[0]===idx(u.x,u.y)){
      const uCur=idx(u.x,u.y);
      occupied[uCur]=v.id;
      occupied[nextI]=u.id;
      v.x=u.x; v.y=u.y;
      u.x=xOf(nextI); u.y=yOf(nextI);
      v.path.shift();
      u.path.shift();
      v.stuckTicks=0; u.stuckTicks=0;
      return true;
    }

    if(!isPushableUnit(v)) return false;
    const free=findFreeNeighborForUnit(v, nextI);
    if(free===-1) return false;

    occupied[idx(v.x,v.y)]=-1;
    v.x=xOf(free); v.y=yOf(free);
    occupied[free]=v.id;

    occupied[idx(u.x,u.y)]=-1;
    u.x=xOf(nextI); u.y=yOf(nextI);
    occupied[nextI]=u.id;
    u.path.shift();
    u.stuckTicks=0;
    return true;
  }

  function tryStepFromPath(u){
    if(!u.path || !u.path.length) return false;
    const nextI=u.path[0];
    const occ=occupied[nextI];
    if(occ!==-1){
      u.stuckTicks++;
      if(u.stuckTicks >= PUSH_STUCK_TICKS){
        if(tryYieldOrPush(u,nextI)) return true;
      }
      return false;
    }
    // also avoid animals on next tile (units treat animals as solid)
    if(animalAt[nextI]!==-1){
      u.stuckTicks++;
      return false;
    }

    occupied[idx(u.x,u.y)]=-1;
    u.x=xOf(nextI); u.y=yOf(nextI);
    u.path.shift();
    occupied[nextI]=u.id;
    u.stuckTicks=0;
    return true;
  }

  // --- unit data & roles ---
  let HP_LUMBER=10, HP_MINER=10, HP_HUNTER=12, HP_SCOUT=8;
  function roleMaxHP(role){
    if(role==="lumber") return HP_LUMBER;
    if(role==="miner") return HP_MINER;
    if(role==="hunter") return HP_HUNTER;
    if(role==="scout") return HP_SCOUT;
    return 10;
  }
  function isWorkerRole(role){ return role==="lumber"||role==="miner"||role==="hunter"; }
  function makeUnit(id,role,x,y){
    const maxHP=roleMaxHP(role);
    return {
      id, role, x, y,
      state:"Idle",
      intent:null,
      waitingPath:false,
      path:[],
      target:null,             // {type, id} for tree/rock/meat OR {type:"animal", id}
      carry:0,
      progress:0,
      stuckTicks:0,
      nextScoutThinkTick:0,
      exploreTarget:null,
      dropTileI:null,
      parkTileI:null,
      nextDropRetryTick:0,

      hp:maxHP,
      maxHP,
      atkCD:0,                 // seconds until next attack
      flee:false,
      healCD:0,
      resumeTarget:null,
      fleeFromAnimalId:-1,
      lastAttackerAnimalId:-1,
      lastHitTick:-1,
    };
  }

  // --- animals ---
  let animalAt; // Int32Array N -> animal id or -1
  function makeAnimal(id,x,y){
    return {
      id,
      x,y,
      homeX:x, homeY:y,
      hp:ANIMAL_HP,
      maxHP:ANIMAL_HP,
      state:"Wander",           // Wander/Chase/Return/Dead
      targetUnitId:-1,
      atkCD:0,
      moveCD:0,
      thinkT:0,
      wanderTX:x, wanderTY:y,
      meatId:-1,                // spawned meat resource id after death
    };
  }

  function rebuildAnimalOccupancy(){
    animalAt.fill(-1);
    for(const a of animals){
      if(a.state!=="Dead"){
        animalAt[idx(a.x,a.y)] = a.id;
      }
    }
  }

  function animalPickWanderTarget(a){
    // pick a random point within wander radius from home
    for(let tries=0; tries<10; tries++){
      const dx=((Math.random()* (ANIMAL_WANDER_R*2+1))|0)-ANIMAL_WANDER_R;
      const dy=((Math.random()* (ANIMAL_WANDER_R*2+1))|0)-ANIMAL_WANDER_R;
      const tx=a.homeX+dx, ty=a.homeY+dy;
      if(!inBounds(tx,ty)) continue;
      if(cheb(tx,ty,a.homeX,a.homeY)>ANIMAL_WANDER_R) continue;
      const ti=idx(tx,ty);
      if(!isWalkableTile(ti)) continue;
      a.wanderTX=tx; a.wanderTY=ty;
      return;
    }
    a.wanderTX=a.homeX; a.wanderTY=a.homeY;
  }

  function animalStepGreedy(a, tx, ty){
    // choose neighbor that reduces Chebyshev distance, avoid blocked tiles/units/resources
    const curI=idx(a.x,a.y);
    let bestI=-1, bestD=1e9;

    // shuffled dirs for natural movement
    const start=((Math.random()*8)|0);
    for(let k=0;k<8;k++){
      const d=DIRS8[(start+k)&7];
      const nx=a.x+d.dx, ny=a.y+d.dy;
      if(!inBounds(nx,ny)) continue;
      const ni=idx(nx,ny);
      if(!isWalkableTile(ni)) continue;
      if(!canMoveDiag(curI,ni)) continue;

      if(occupied[ni]!==-1) continue;     // don't step onto unit
      if(animalAt[ni]!==-1) continue;      // don't step onto other animal

      const dist=cheb(nx,ny,tx,ty);
      if(dist<bestD){ bestD=dist; bestI=ni; }
    }
    if(bestI===-1) return false;
    animalAt[curI]=-1;
    a.x=xOf(bestI); a.y=yOf(bestI);
    animalAt[bestI]=a.id;
    return true;
  }

  function animalNearestHostileInRange(a, range=1){
    // animals only fight target unit if adjacent; this is called by combat logic
    if(a.targetUnitId<0) return null;
    const u=units[a.targetUnitId];
    if(!u) return null;
    if(cheb(a.x,a.y,u.x,u.y)<=range) return u;
    return null;
  }

  function spawnMeatAt(x,y){
    // meat becomes a resource tile at the animal's death location
    const i=idx(x,y);
    if(resType[i]!==ResT.None) return -1;
    const id=meats.length;
    meats.push({id,x,y,amt:MEAT_MIN+((Math.random()*(MEAT_MAX-MEAT_MIN+1))|0), alive:true});
    resType[i]=ResT.Meat;
    resIdAt[i]=id;
    if(explored[i]){ // only draw if explored already; else draw upon discovery
      drawMeatTile(x,y);
      knownMeatIds.push(id);
    }
    return id;
  }

  // --- combat helpers ---
  function dealDamageUnit(u, dmg, attackerAnimalId){
    u.hp = Math.max(0, u.hp-dmg);
    if(attackerAnimalId!=null) u.lastAttackerAnimalId = attackerAnimalId;
    u.lastHitTick = tickCount;
    if(u.hp<=0){
      // unit "dies": remove from occupied and mark as removed
      occupied[idx(u.x,u.y)] = -1;
      u.dead=true;
      u.state="Dead";
      // release reservations
      if(u.dropTileI!=null){ releaseReservation(u.id, dropTiles, dropReservedBy); u.dropTileI=null; }
      if(u.parkTileI!=null){ releaseReservation(u.id, parkTiles, parkReservedBy); u.parkTileI=null; }
      log(`陣亡：${u.role}#${u.id}`);
    } else {
      // flee trigger for workers
      if(isWorkerRole(u.role) && !u.flee && (u.hp/u.maxHP)<=FLEE_HP_FRAC){
        u.resumeTarget = u.target ? {type:u.target.type, id:u.target.id} : null;
        u.fleeFromAnimalId = u.lastAttackerAnimalId ?? -1;
        u.flee=true;
        u.target=null;
        u.path=[];
        u.intent=null;
        u.state="Flee";
        log(`逃跑：${u.role}#${u.id} (${u.hp}/${u.maxHP})`);
      }
    }
  }

  function dealDamageAnimal(a, dmg){
    a.hp = Math.max(0, a.hp-dmg);
    if(a.hp<=0 && a.state!=="Dead"){
      a.state="Dead";
      animalAt[idx(a.x,a.y)] = -1;
      a.targetUnitId=-1;
      // spawn meat
      a.meatId = spawnMeatAt(a.x,a.y);
      log(`動物擊殺：#${a.id} 掉落肉${a.meatId>=0?("#"+a.meatId):"(失敗)"}`);
    }
  }

  // --- worker target selection ---
  function adjacentStandTilesForRes(resI){
    const x=xOf(resI), y=yOf(resI);
    const out=[];
    for(let dy=-1; dy<=1; dy++){
      for(let dx=-1; dx<=1; dx++){
        if(dx===0 && dy===0) continue;
        const nx=x+dx, ny=y+dy;
        if(!inBounds(nx,ny)) continue;
        const ni=idx(nx,ny);
        if(!isWalkableTile(ni)) continue;
        // avoid animals and units
        if(occupied[ni]!==-1) continue;
        if(animalAt[ni]!==-1) continue;
        out.push(ni);
      }
    }
    return out;
  }
  function chooseBestStandTile(u,resI){
    const opts=adjacentStandTilesForRes(resI);
    if(!opts.length) return -1;
    let best=opts[0], bestD=1e9;
    for(const i of opts){
      const d=Math.abs(xOf(i)-u.x)+Math.abs(yOf(i)-u.y);
      if(d<bestD){ bestD=d; best=i; }
    }
    return best;
  }

  function pickTargetForWorker(u){
    let type=null;
    if(u.role==="lumber") type="tree";
    else if(u.role==="miner") type="rock";
    else if(u.role==="hunter"){
      // hunter: prefer meat if any known; else hunt animals if known in explored area
      if(knownMeatIds.length) type="meat";
      else type="animal";
    }

    let preferredId=null;
    if(preferred.type===type && preferred.id!=null) preferredId=preferred.id;

    // choose from known lists
    if(type==="tree"){
      return pickFromKnown(u, type, knownTreeIds, trees, preferredId);
    } else if(type==="rock"){
      return pickFromKnown(u, type, knownRockIds, rocks, preferredId);
    } else if(type==="meat"){
      return pickFromKnown(u, type, knownMeatIds, meats, preferredId);
    } else if(type==="animal"){
      return pickAnimalTarget(u, preferredId);
    }
    return null;
  }

  function pickFromKnown(u, type, knownIds, arr, preferredId){
    if(!knownIds.length) return null;
    const K=Math.min(SAMPLE_K, knownIds.length);
    let bestId=null, bestScore=Infinity;

    function consider(id){
      const res=arr[id];
      if(!res || !res.alive) return;
      const ri=idx(res.x,res.y);
      const stand=chooseBestStandTile(u,ri);
      if(stand===-1) return;
      const d=manhattan(u.x,u.y,res.x,res.y);

      let load=0;
      for(const w of workers){
        if(w.target && w.target.type===type && w.target.id===id) load++;
      }
      let score=d + 3.2*load;
      if(preferredId!==null && id===preferredId) score*=0.25;
      if(score<bestScore){ bestScore=score; bestId=id; }
    }

    if(preferredId!==null) consider(preferredId);
    for(let s=0;s<K;s++){
      const id=knownIds[(Math.random()*knownIds.length)|0];
      consider(id);
    }
    if(bestId===null) return null;
    return {type, id: bestId};
  }

  function pickAnimalTarget(u, preferredId){
    // pick nearest visible/explored animal by sampling
    if(!animals || !animals.length) return null;

    // avoid aggroing too many animals at once
    const engaged=new Set();
    let hunterCount=0;
    for(const w of workers){
      if(w.role!=="hunter" || w.dead) continue;
      hunterCount++;
      if(w.target && w.target.type==="animal") engaged.add(w.target.id);
    }
    // only start hunting if we have at least 2 hunters
    if(engaged.size===0 && hunterCount<2 && preferredId==null) return null;
    const maxEngage=Math.max(1, Math.floor(hunterCount/2));

    const K=Math.min(80, animals.length);
    let bestId=null, bestScore=Infinity;

    function consider(a){
      if(!a || a.state==="Dead") return;
      if(engaged.size>=maxEngage && !engaged.has(a.id) && preferredId==null) return;
      const ai=idx(a.x,a.y);
      if(!explored[ai]) return; // hunters only consider animals they've "seen"
      const d=manhattan(u.x,u.y,a.x,a.y);
      let load=0;
      for(const w of workers){
        if(w.role==="hunter" && w.target && w.target.type==="animal" && w.target.id===a.id) load++;
      }
      // encourage grouping: prefer animals already engaged
      let score = d + (load>0 ? -4.0*load : 6.0);
      if(preferredId!=null && a.id===preferredId) score*=0.25;
      if(score<bestScore){ bestScore=score; bestId=a.id; }
    }

    if(preferredId!=null){
      const a=animals[preferredId];
      if(a) consider(a);
    }
    for(let s=0;s<K;s++){
      const a=animals[(Math.random()*animals.length)|0];
      consider(a);
    }
    if(bestId==null) return null;
    return {type:"animal", id: bestId};
  }

  function requestMoveToResource(u,target){
    if(target.type==="tree"){
      const res=trees[target.id]; if(!res||!res.alive) return false;
      const stand=chooseBestStandTile(u, idx(res.x,res.y)); if(stand===-1) return false;
      u.target=target; u.intent=null; requestPath(u.id, stand); return true;
    }
    if(target.type==="rock"){
      const res=rocks[target.id]; if(!res||!res.alive) return false;
      const stand=chooseBestStandTile(u, idx(res.x,res.y)); if(stand===-1) return false;
      u.target=target; u.intent=null; requestPath(u.id, stand); return true;
    }
    if(target.type==="meat"){
      const res=meats[target.id]; if(!res||!res.alive) return false;
      const stand=chooseBestStandTile(u, idx(res.x,res.y)); if(stand===-1) return false;
      u.target=target; u.intent=null; requestPath(u.id, stand); return true;
    }
    if(target.type==="animal"){
      const a=animals[target.id]; if(!a||a.state==="Dead") return false;
      // For melee: go to a standable neighbor of animal tile (not on animal)
      const ai=idx(a.x,a.y);
      const opts=adjacentStandTilesForRes(ai);
      if(!opts.length) return false;
      // pick closest option
      let best=opts[0], bestD=1e9;
      for(const i of opts){
        const d=Math.abs(xOf(i)-u.x)+Math.abs(yOf(i)-u.y);
        if(d<bestD){ bestD=d; best=i; }
      }
      u.target=target; u.intent=null; requestPath(u.id, best); return true;
    }
    return false;
  }

  // --- storage logic (parking) ---
  function ensureDropReservation(u){
    if(u.dropTileI!=null && dropReservedBy[u.dropTileI]===u.id) return u.dropTileI;
    u.dropTileI = reserveTileFromList(u.id, dropTiles, dropReservedBy);
    return u.dropTileI;
  }
  function ensureParkReservation(u){
    if(u.parkTileI!=null && parkReservedBy[u.parkTileI]===u.id) return u.parkTileI;
    u.parkTileI = reserveTileFromList(u.id, parkTiles, parkReservedBy);
    return u.parkTileI;
  }

  function requestMoveToStorageLogic(u){
    if(isAdjacentToStorage(u.x,u.y)){ u.state="Dropoff"; return; }

    const dropI=ensureDropReservation(u);
    if(dropI!==-1){
      if(u.parkTileI!=null){ releaseReservation(u.id, parkTiles, parkReservedBy); u.parkTileI=null; }
      u.intent="ToStorage";
      requestPath(u.id, dropI);
      u.state="ToStorage";
      return;
    }

    const parkI=ensureParkReservation(u);
    if(parkI!==-1){
      u.intent="ToPark";
      requestPath(u.id, parkI);
      u.state="ToPark";
      u.nextDropRetryTick = tickCount + Math.max(6, (TICK_HZ/2)|0);
      return;
    }

    u.state="QueueStorage";
    u.intent="ToStorage";
    u.nextDropRetryTick = tickCount + Math.max(6, (TICK_HZ/2)|0);
  }

  function doDropoff(u){
    if(!isAdjacentToStorage(u.x,u.y)){ requestMoveToStorageLogic(u); return; }
    if(u.carry>0){
      if(u.role==="lumber") storage.wood += u.carry;
      else if(u.role==="miner") storage.ore += u.carry;
      else if(u.role==="hunter") storage.food += u.carry;
      u.carry=0;
    }
    if(u.dropTileI!=null){ releaseReservation(u.id, dropTiles, dropReservedBy); u.dropTileI=null; }
    if(u.parkTileI!=null){ releaseReservation(u.id, parkTiles, parkReservedBy); u.parkTileI=null; }
    u.state="Idle";
    u.target=null;
    u.intent=null;
  }

  // --- fleeing ---
  function requestFlee(u){
    // go park; if no park, go drop; else wait
    const parkI=ensureParkReservation(u);
    if(parkI!==-1){
      u.intent="ToPark"; requestPath(u.id, parkI); u.state="ToPark";
      return;
    }
    const dropI=ensureDropReservation(u);
    if(dropI!==-1){
      u.intent="ToStorage"; requestPath(u.id, dropI); u.state="ToStorage";
      return;
    }
    u.state="QueueStorage";
    u.nextDropRetryTick=tickCount + Math.max(6,(TICK_HZ/2)|0);
  }

  function pickFreeTileFromList(u, list){
    let best=-1, bestD=1e9;
    for(const ti of list){
      if(occupied[ti]!==-1) continue;
      if(animalAt[ti]!==-1) continue;
      if(!isWalkableTile(ti)) continue;
      const d = Math.abs(xOf(ti)-u.x)+Math.abs(yOf(ti)-u.y);
      if(d<bestD){ bestD=d; best=ti; }
    }
    return best;
  }

  function tickWorkerFleeRecovery(u){
    if(!u.flee || !isWorkerRole(u.role)) return false;

    u.healCD = Math.max(0, u.healCD-STEP_TIME);
    const inParkRing = (distToStorage(u.x,u.y)===PARK_RING_R);
    if(inParkRing && u.healCD<=0){
      if(u.hp < u.maxHP && storage.food>0){
        u.hp = Math.min(u.maxHP, u.hp+1);
        storage.food -= 1;
      }
      u.healCD = HUNTER_HEAL_INTERVAL;
    }

    if((u.hp/u.maxHP) >= HUNTER_RESUME_HP_FRAC){
      u.flee=false;
      u.state="Idle";
      u.intent=null;
      u.path=[];
      if(u.parkTileI!=null){ releaseReservation(u.id, parkTiles, parkReservedBy); u.parkTileI=null; }
      if(u.dropTileI!=null){ releaseReservation(u.id, dropTiles, dropReservedBy); u.dropTileI=null; }
      if(u.resumeTarget){ u.target=u.resumeTarget; u.resumeTarget=null; }
      return true;
    }
    return false;
  }

  // --- worker tick ---
  function tickWorker(u){
    if(u.dead) return;
    if(u.waitingPath) return;

    // if fleeing: just run to parking and stay there (do not return to work)
    if(u.flee){
      if(u.state==="Fight"){ u.state="Idle"; u.target=null; }
      if(u.state==="Idle" || u.state==="Work" || u.state==="Flee"){ requestFlee(u); }
      // movement handled below
    }
    if(u.flee){
      tickWorkerFleeRecovery(u);
    }

    if(u.state==="Move" || u.state==="ToStorage" || u.state==="ToPark"){
      const moved=tryStepFromPath(u);
      // Allow hunters to start fighting while still moving if in range
      if(u.role==="hunter" && u.target && u.target.type==="animal"){
        const a=animals[u.target.id];
        if(a && a.state!=="Dead" && cheb(u.x,u.y,a.x,a.y)<=2){
          u.state="Fight";
          u.path=[];
          u.stuckTicks=0;
          a.targetUnitId=u.id;
          a.state="Chase";
          return;
        }
      }
      if(!moved){
        if(u.stuckTicks>16){
          u.stuckTicks=0;
          if(u.path && u.path.length){
            requestPath(u.id, u.path[u.path.length-1]);
          } else {
            u.state="Idle"; u.target=null; u.intent=null;
          }
        }
        if(u.flee && u.stuckTicks>8){
          // re-request parking/drop reservation to reduce getting stuck in crowds
          requestFlee(u);
        }
        return;
      }
      if(!u.path.length){
        if(u.state==="ToPark") u.state="Parked";
        else if(u.state==="ToStorage") u.state="Dropoff";
        else u.state="Work";
        u.progress=0;
      }
      return;
    }

    if(u.state==="Parked" || u.state==="QueueStorage"){
      if(u.flee){
        // if not yet at park ring, try to move toward it
        if(distToStorage(u.x,u.y)!==PARK_RING_R){
          const parkI=ensureParkReservation(u);
          if(parkI!==-1){
            u.intent="ToPark"; requestPath(u.id, parkI); u.state="ToPark";
            return;
          }
          const freeI=pickFreeTileFromList(u, parkTiles);
          if(freeI!==-1){
            u.intent="ToPark"; requestPath(u.id, freeI); u.state="ToPark";
            return;
          }
        }
        return;
      }
      if(tickCount >= u.nextDropRetryTick){
        u.nextDropRetryTick = tickCount + Math.max(6, (TICK_HZ/2)|0);
        const dropI=ensureDropReservation(u);
        if(dropI!==-1){
          if(u.parkTileI!=null){ releaseReservation(u.id, parkTiles, parkReservedBy); u.parkTileI=null; }
          u.intent="ToStorage"; requestPath(u.id, dropI); u.state="ToStorage";
        } else if(u.state==="QueueStorage"){
          const parkI=ensureParkReservation(u);
          if(parkI!==-1){
            u.intent="ToPark"; requestPath(u.id, parkI); u.state="ToPark";
          } else {
            // soft move toward storage even without reservation to avoid stuck at resource
            const freeI=pickFreeTileFromList(u, parkTiles);
            if(freeI!==-1){
              u.intent="ToPark"; requestPath(u.id, freeI); u.state="ToPark";
            }
          }
        }
      }
      return;
    }

    if(u.state==="Dropoff"){
      doDropoff(u);
      return;
    }

    // Combat / attack if hunter target is animal and in range
    if(u.role==="hunter" && u.target && u.target.type==="animal"){
      const a=animals[u.target.id];
      if(!a || a.state==="Dead"){
        u.target=null;
        u.state="Idle";
      } else {
        // If within range, fight (hunter range = 2)
        if(cheb(u.x,u.y,a.x,a.y)<=2 && !(u.x===a.x && u.y===a.y)){
          u.state="Fight";
          // set animal aggro
          a.targetUnitId=u.id;
          a.state="Chase";
        }
      }
    }

    if(u.state==="Fight"){
      const a= u.target ? animals[u.target.id] : null;
      if(!a || a.state==="Dead"){ u.state="Idle"; u.target=null; return; }
      // if no longer in range, chase again
      if(cheb(u.x,u.y,a.x,a.y)>2){
        requestMoveToResource(u, u.target);
        return;
      }
      // attack cooldown
      u.atkCD = Math.max(0, u.atkCD-STEP_TIME);
      if(u.atkCD<=0){
        u.atkCD = ATK_INTERVAL;
        dealDamageAnimal(a, ATK_DAMAGE);
      }
      // after kill, hunter should switch to meat if spawned & visible
      if(a.state==="Dead" && a.meatId>=0){
        u.target=null;
        u.state="Idle";
      }
      return;
    }

    if(u.state==="Work"){
      if(!u.target){ u.state="Idle"; return; }

      // if fleeing interrupt
      if(u.flee){ requestFlee(u); return; }
      // survival first: if recently hit by animal, break off work and flee
      if(u.role!=="hunter" && u.lastHitTick>=0 && (tickCount - u.lastHitTick) <= (TICK_HZ*2|0)){
        if((u.hp/u.maxHP) <= FLEE_HIT_FRAC){
          u.flee=true;
          u.target=null;
          u.path=[];
          u.intent=null;
          u.state="Flee";
          requestFlee(u);
          return;
        }
      }

      // Gather from resource
      if(u.target.type==="tree"){
        const res=trees[u.target.id];
        if(!res||!res.alive){ if(u.carry>0) requestMoveToStorageLogic(u); else {u.state="Idle";u.target=null;} return; }
        if(Math.abs(u.x-res.x)>1 || Math.abs(u.y-res.y)>1 || (u.x===res.x && u.y===res.y)){
          requestMoveToResource(u, u.target); return;
        }
        u.progress += STEP_TIME;
        while(u.progress>=1.0 && u.carry<WORKER_CARRY_CAP && res.amt>0){
          u.progress -= 1.0;
          const take=Math.min(CHOP_RATE, res.amt, WORKER_CARRY_CAP-u.carry);
          res.amt-=take; u.carry+=take;
        }
        if(res.amt<=0){
          res.alive=false;
          const ri=idx(res.x,res.y);
          resType[ri]=ResT.None; resIdAt[ri]=-1;
          eraseTileToBackground(ri);
          if(preferred.type==="tree" && preferred.id===res.id) preferred={type:null,id:null};
          if(u.carry>0) requestMoveToStorageLogic(u); else {u.state="Idle";u.target=null;}
          return;
        }
        if(u.carry>=WORKER_CARRY_CAP){ requestMoveToStorageLogic(u); return; }
        return;
      }

      if(u.target.type==="rock"){
        const res=rocks[u.target.id];
        if(!res||!res.alive){ if(u.carry>0) requestMoveToStorageLogic(u); else {u.state="Idle";u.target=null;} return; }
        if(Math.abs(u.x-res.x)>1 || Math.abs(u.y-res.y)>1 || (u.x===res.x && u.y===res.y)){
          requestMoveToResource(u, u.target); return;
        }
        u.progress += STEP_TIME;
        while(u.progress>=1.0 && u.carry<WORKER_CARRY_CAP && res.amt>0){
          u.progress -= 1.0;
          const take=Math.min(MINE_RATE, res.amt, WORKER_CARRY_CAP-u.carry);
          res.amt-=take; u.carry+=take;
        }
        if(res.amt<=0){
          res.alive=false;
          const ri=idx(res.x,res.y);
          resType[ri]=ResT.None; resIdAt[ri]=-1;
          eraseTileToBackground(ri);
          if(preferred.type==="rock" && preferred.id===res.id) preferred={type:null,id:null};
          if(u.carry>0) requestMoveToStorageLogic(u); else {u.state="Idle";u.target=null;}
          return;
        }
        if(u.carry>=WORKER_CARRY_CAP){ requestMoveToStorageLogic(u); return; }
        return;
      }

      if(u.target.type==="meat"){
        const res=meats[u.target.id];
        if(!res||!res.alive){ if(u.carry>0) requestMoveToStorageLogic(u); else {u.state="Idle";u.target=null;} return; }
        if(Math.abs(u.x-res.x)>1 || Math.abs(u.y-res.y)>1 || (u.x===res.x && u.y===res.y)){
          requestMoveToResource(u, u.target); return;
        }
        u.progress += STEP_TIME;
        while(u.progress>=1.0 && u.carry<WORKER_CARRY_CAP && res.amt>0){
          u.progress -= 1.0;
          const take=Math.min(MEAT_RATE, res.amt, WORKER_CARRY_CAP-u.carry);
          res.amt-=take; u.carry+=take;
        }
        if(res.amt<=0){
          res.alive=false;
          const ri=idx(res.x,res.y);
          resType[ri]=ResT.None; resIdAt[ri]=-1;
          eraseTileToBackground(ri);
          if(preferred.type==="meat" && preferred.id===res.id) preferred={type:null,id:null};
          if(u.carry>0) requestMoveToStorageLogic(u); else {u.state="Idle";u.target=null;}
          return;
        }
        if(u.carry>=WORKER_CARRY_CAP){ requestMoveToStorageLogic(u); return; }
        return;
      }

      if(u.target.type==="animal"){
        // should not be in Work; hunters fight in Fight state
        u.state="Idle";
        return;
      }
    }

    // Idle
    if(u.state==="Idle"){
      if(u.dropTileI!=null && dropReservedBy[u.dropTileI]!==u.id) u.dropTileI=null;
      if(u.parkTileI!=null && parkReservedBy[u.parkTileI]!==u.id) u.parkTileI=null;

      if(u.flee){
        requestFlee(u);
        return;
      }

      if(u.carry>0){ requestMoveToStorageLogic(u); return; }

      if(u.resumeTarget){
        const t=u.resumeTarget;
        u.resumeTarget=null;
        const ok=requestMoveToResource(u, t);
        if(ok) return;
      }

      const target=pickTargetForWorker(u);
      if(!target) return;
      const ok=requestMoveToResource(u,target);
      if(ok){
        // if hunter going to animal, state will be Move; once near, switches to Fight
        return;
      }
      u.target=null;
    }
  }

  // --- scout ---
  function pickFrontierForScout(u){
    let best=-1, bestD=1e9;
    for(let s=0;s<120;s++){
      const x=(Math.random()*W)|0, y=(Math.random()*H)|0;
      const i=idx(x,y);
      if(!explored[i]) continue;
      let hasUn=false;
      for(let dy=-1; dy<=1; dy++){
        for(let dx=-1; dx<=1; dx++){
          if(dx===0&&dy===0) continue;
          const nx=x+dx, ny=y+dy;
          if(!inBounds(nx,ny)) continue;
          if(!explored[idx(nx,ny)]) { hasUn=true; break; }
        }
        if(hasUn) break;
      }
      if(!hasUn) continue;
      if(grid[i]===Tile.Block) continue;
      if(!isWalkableTile(i) && grid[i]!==Tile.Storage) continue;
      if(animalAt[i]!==-1) continue;

      const d=Math.abs(x-u.x)+Math.abs(y-u.y);
      if(d<bestD){ bestD=d; best=i; }
    }
    return best;
  }
  function tickScout(u){
    if(u.dead) return;
    if(u.waitingPath) return;

    if(u.state==="Move" || u.state==="Explore"){
      const moved=tryStepFromPath(u);
      if(!moved){
        if(u.stuckTicks>16){
          u.stuckTicks=0;
          if(u.path && u.path.length){
            requestPath(u.id, u.path[u.path.length-1]);
          } else u.state="Idle";
        }
        return;
      }
      if(!u.path.length){
        u.state="Idle";
        u.exploreTarget=null;
      }
      return;
    }

    if(tickCount>=u.nextScoutThinkTick){
      u.nextScoutThinkTick = tickCount + Math.max(10, (TICK_HZ|0));
      const fi=pickFrontierForScout(u);
      if(fi!==-1){
        u.exploreTarget=fi;
        u.intent=null;
        requestPath(u.id, fi);
        u.state="Explore";
      }
    }
  }

  // --- animal tick ---
  function animalAcquireTarget(a){
    // If already has target, keep unless dead or too far beyond leash
    if(a.targetUnitId>=0){
      const u=units[a.targetUnitId];
      if(!u || u.dead){ a.targetUnitId=-1; return; }
      if(cheb(u.x,u.y,a.homeX,a.homeY) > ANIMAL_LEASH_R){ a.targetUnitId=-1; return; }
      return;
    }
    // Find adjacent hunter/worker that is attacking (we set in fight), or any unit in 2 tiles? keep simple:
    // scan nearby tiles within 2 for any unit that is not dead, not scout, and not fleeing
    const r=2;
    for(let dy=-r; dy<=r; dy++){
      for(let dx=-r; dx<=r; dx++){
        const x=a.x+dx, y=a.y+dy;
        if(!inBounds(x,y)) continue;
        const i=idx(x,y);
        const uid=occupied[i];
        if(uid===-1) continue;
        const u=units[uid];
        if(!u || u.dead) continue;
        if(u.role==="scout") continue;
        // only aggro if within leash
        if(cheb(u.x,u.y,a.homeX,a.homeY) > ANIMAL_LEASH_R) continue;
        a.targetUnitId=u.id;
        return;
      }
    }
  }

  function tickAnimal(a){
    if(a.state==="Dead") return;

    // cooldowns
    a.atkCD=Math.max(0, a.atkCD-STEP_TIME);
    a.thinkT=Math.max(0, a.thinkT-STEP_TIME);
    a.moveCD=Math.max(0, a.moveCD-STEP_TIME);

    // If has target but target ran too far, drop aggro
    if(a.targetUnitId>=0){
      const u=units[a.targetUnitId];
      if(!u || u.dead || cheb(u.x,u.y,a.homeX,a.homeY)>ANIMAL_LEASH_R){
        a.targetUnitId=-1;
      }
    }

    // Choose state
    if(a.targetUnitId>=0){
      a.state="Chase";
    } else {
      // If far from home, return; else wander
      if(cheb(a.x,a.y,a.homeX,a.homeY)>ANIMAL_WANDER_R) a.state="Return";
      else a.state="Wander";
    }

    // Try acquire target opportunistically
    animalAcquireTarget(a);

    if(a.state==="Chase" && a.targetUnitId>=0){
      const u=units[a.targetUnitId];
      if(!u || u.dead){ a.targetUnitId=-1; return; }

      // attack if adjacent
      if(cheb(a.x,a.y,u.x,u.y)<=1 && !(a.x===u.x && a.y===u.y)){
        if(a.atkCD<=0){
          a.atkCD=ATK_INTERVAL;
          dealDamageUnit(u, ATK_DAMAGE, a.id);
        }
      } else {
        // move closer (greedy) at slower speed
        if(a.moveCD<=0){
          animalStepGreedy(a, u.x, u.y);
          a.moveCD=ANIMAL_MOVE_INTERVAL;
        }
      }
      return;
    }

    if(a.state==="Return"){
      // go home
      if(cheb(a.x,a.y,a.homeX,a.homeY)>0){
        if(a.moveCD<=0){
          animalStepGreedy(a, a.homeX, a.homeY);
          a.moveCD=ANIMAL_MOVE_INTERVAL;
        }
      }
      return;
    }

    // Wander
    if(a.thinkT<=0){
      a.thinkT = ANIMAL_THINK_MIN + Math.random()*(ANIMAL_THINK_MAX-ANIMAL_THINK_MIN);
      animalPickWanderTarget(a);
    }
    if(cheb(a.x,a.y,a.wanderTX,a.wanderTY)>0){
      if(a.moveCD<=0){
        animalStepGreedy(a, a.wanderTX, a.wanderTY);
        a.moveCD=ANIMAL_MOVE_INTERVAL;
      }
    }
  }

  // --- generation helpers ---
  function addObstaclePatches(percent){
    const target=Math.floor(N*(percent/100));
    let added=0;
    const rects=Math.max(3, Math.floor(percent/2));
    for(let r=0;r<rects;r++){
      const rw=6+((Math.random()*18)|0);
      const rh=4+((Math.random()*14)|0);
      const x0=((Math.random()*(W-rw))|0);
      const y0=((Math.random()*(H-rh))|0);
      for(let y=y0;y<y0+rh;y++){
        for(let x=x0;x<x0+rw;x++){
          const i=idx(x,y);
          if(grid[i]!==Tile.Block){ grid[i]=Tile.Block; added++; }
        }
      }
    }
    let guard=0;
    while(added<target && guard<300000){
      guard++;
      const x=(Math.random()*W)|0, y=(Math.random()*H)|0;
      const i=idx(x,y);
      if(grid[i]===Tile.Block) continue;
      grid[i]=Tile.Block; added++;
    }
    return added;
  }

  function spawnClusteredPoints(count, occupiedSet, avoid){
    const clusters=Math.max(4, Math.floor(Math.sqrt(Math.max(1,count))/1.2));
    const centers=[];
    let tries=0;
    while(centers.length<clusters && tries<200000){
      tries++;
      const x=(Math.random()*W)|0, y=(Math.random()*H)|0;
      const k=`${x},${y}`;
      if(occupiedSet.has(k)) continue;
      const i=idx(x,y);
      if(grid[i]===Tile.Block) continue;
      if(manhattan(x,y,avoid.x,avoid.y)<avoid.dist) continue;
      centers.push({x,y});
    }
    const used=new Set();
    const pts=[];
    function place(x,y){
      if(!inBounds(x,y)) return false;
      const k=`${x},${y}`;
      if(used.has(k) || occupiedSet.has(k)) return false;
      const i=idx(x,y);
      if(grid[i]===Tile.Block) return false;
      used.add(k); pts.push({x,y});
      return true;
    }
    let placed=0, guard2=0;
    while(placed<count && guard2<800000){
      guard2++;
      const c=centers[(Math.random()*centers.length)|0];
      const r=(Math.random()<0.75)?6:12;
      const ang=Math.random()*Math.PI*2;
      const rad=Math.abs((Math.random()+Math.random()+Math.random())/3)*r;
      let x=Math.round(c.x+Math.cos(ang)*rad);
      let y=Math.round(c.y+Math.sin(ang)*rad);
      x += ((Math.random()-0.5)*2)|0;
      y += ((Math.random()-0.5)*2)|0;
      if(place(x,y)) placed++;
    }
    let guard3=0;
    while(placed<count && guard3<300000){
      guard3++;
      const x=(Math.random()*W)|0, y=(Math.random()*H)|0;
      if(place(x,y)) placed++;
    }
    return pts;
  }

  function spawnSeparatedPoints(count, occupiedSet, avoid, minDist){
    const pts=[];
    let guard=0;
    while(pts.length<count && guard<800000){
      guard++;
      const x=(Math.random()*W)|0, y=(Math.random()*H)|0;
      const k=`${x},${y}`;
      if(occupiedSet.has(k)) continue;
      const i=idx(x,y);
      if(grid[i]===Tile.Block) continue;
      if(manhattan(x,y,avoid.x,avoid.y)<avoid.dist) continue;
      let ok=true;
      for(const p of pts){
        if(cheb(x,y,p.x,p.y)<minDist){ ok=false; break; }
      }
      if(!ok) continue;
      pts.push({x,y});
      occupiedSet.add(k);
    }
    if(pts.length<count){
      const rest=count-pts.length;
      const extra=spawnClusteredPoints(rest, occupiedSet, avoid);
      for(const p of extra) pts.push(p);
    }
    return pts;
  }

  // --- sim state ---
  let simState="READY";
  let tickCount=0;
  function setStatus(s){ statusTag.textContent=s; }

  function generate(params){
    TILEPX=params.tilePx;
    TICK_HZ=params.tickHz;
    STEP_TIME=1/TICK_HZ;
    ASTAR_BUDGET=params.astarBudget;
    SAMPLE_K=params.sampleK;
    HP_LUMBER=params.hpLumber;
    HP_MINER=params.hpMiner;
    HP_HUNTER=params.hpHunter;
    HP_SCOUT=params.hpScout;
    ANIMAL_HP=params.hpAnimal;

    resizeCanvases();

    grid=new Uint8Array(N);
    occupied=new Int32Array(N); occupied.fill(-1);
    animalAt=new Int32Array(N); animalAt.fill(-1);

    resType=new Uint8Array(N);
    resIdAt=new Int32Array(N); resIdAt.fill(-1);

    trees=[]; rocks=[]; meats=[];
    animals=[];
    units=[]; workers=[]; scouts=[];
    preferred={type:null,id:null};
    storage={x:(W/2)|0, y:(H/2)|0, wood:0, ore:0, food:0};

    grid[idx(storage.x,storage.y)] = Tile.Storage;

    addObstaclePatches(params.obsPercent);

    // clear around storage
    for(let y=storage.y-4;y<=storage.y+4;y++){
      for(let x=storage.x-4;x<=storage.x+4;x++){
        if(!inBounds(x,y)) continue;
        const i=idx(x,y);
        grid[i] = (x===storage.x && y===storage.y) ? Tile.Storage : Tile.Empty;
      }
    }

    // spawn units
    const occ=new Set([`${storage.x},${storage.y}`]);
    function spawnRole(n,role){
      let created=0;
      for(let ring=1; created<n && ring<60; ring++){
        for(let dy=-ring; dy<=ring && created<n; dy++){
          for(let dx=-ring; dx<=ring && created<n; dx++){
            if(Math.abs(dx)!==ring && Math.abs(dy)!==ring) continue;
            const x=storage.x+dx, y=storage.y+dy;
            if(!inBounds(x,y)) continue;
            const i=idx(x,y);
            if(grid[i]===Tile.Block) continue;
            const k=`${x},${y}`;
            if(occ.has(k)) continue;
            const id=units.length;
            const u=makeUnit(id,role,x,y);
            units.push(u);
            if(role==="scout") scouts.push(u); else workers.push(u);
            occ.add(k);
            created++;
          }
        }
      }
      while(created<n){
        const x=storage.x+1, y=storage.y;
        const id=units.length;
        const u=makeUnit(id,role,x,y);
        units.push(u);
        if(role==="scout") scouts.push(u); else workers.push(u);
        created++;
      }
    }

    spawnRole(params.lumberCount,"lumber");
    spawnRole(params.minerCount,"miner");
    spawnRole(params.hunterCount,"hunter");
    spawnRole(params.scoutCount,"scout");

    rebuildOccupancy();

    // spawn trees/rocks
    const treePts=spawnClusteredPoints(params.treeCount, occ, {x:storage.x,y:storage.y,dist:10});
    trees = treePts.map((p,i)=>({id:i,x:p.x,y:p.y,amt:TREE_MIN+((Math.random()*(TREE_MAX-TREE_MIN+1))|0), alive:true}));
    for(const t of trees){
      const ti=idx(t.x,t.y);
      resType[ti]=ResT.Tree; resIdAt[ti]=t.id;
      occ.add(`${t.x},${t.y}`);
    }
    const rockPts=spawnClusteredPoints(params.rockCount, occ, {x:storage.x,y:storage.y,dist:12});
    rocks = rockPts.map((p,i)=>({id:i,x:p.x,y:p.y,amt:ROCK_MIN+((Math.random()*(ROCK_MAX-ROCK_MIN+1))|0), alive:true}));
    for(const r of rocks){
      const ri=idx(r.x,r.y);
      resType[ri]=ResT.Rock; resIdAt[ri]=r.id;
    }

    // spawn animals (avoid storage, avoid obstacles/resources)
    const animalPts=spawnSeparatedPoints(params.animalCount, occ, {x:storage.x,y:storage.y,dist:14}, ANIMAL_MIN_DIST);
    animals = animalPts.map((p,i)=>makeAnimal(i,p.x,p.y));
    rebuildAnimalOccupancy();

    // rings & reservations
    buildRings();
    dropReservedBy=new Int32Array(N); dropReservedBy.fill(-1);
    parkReservedBy=new Int32Array(N); parkReservedBy.fill(-1);

    // fog
    visOffsetsWorker=buildOffsets(params.visionWorker);
    visOffsetsScout=buildOffsets(params.visionScout);
    clearFog();

    initAstarArrays();

    drawBaseAll();
    visiblePrev.fill(0);
    updateVisibilityAndFogLayers();
    drawFogAll();
    updateVisibilityAndFogLayers();

    // reset
    pathQueue=[];
    tickCount=0;
    simState="READY";
    setStatus("READY");
    log(`生成完成：工人(含獵人)=${workers.length} 斥侯=${scouts.length} 動物=${animals.length}`);
    updateInfo();
    render();
  }

  // click preference
  canvas.addEventListener("click",(ev)=>{
    if(!grid) return;
    const rect=canvas.getBoundingClientRect();
    const mx=((ev.clientX-rect.left)/TILEPX)|0;
    const my=((ev.clientY-rect.top)/TILEPX)|0;
    if(!inBounds(mx,my)) return;
    const i=idx(mx,my);
    if(!explored[i]) { log(`(點擊) 未探索：(${mx},${my})`); return; }
    const rt=resType[i];
    if(rt===ResT.Tree){ preferred={type:"tree",id:resIdAt[i]}; log(`偏好目標：樹#${preferred.id} @(${mx},${my})`); }
    else if(rt===ResT.Rock){ preferred={type:"rock",id:resIdAt[i]}; log(`偏好目標：礦#${preferred.id} @(${mx},${my})`); }
    else if(rt===ResT.Meat){ preferred={type:"meat",id:resIdAt[i]}; log(`偏好目標：肉#${preferred.id} @(${mx},${my})`); }
    else log(`(點擊) 不是樹/礦/肉：(${mx},${my})`);
  });

  // --- sim tick ---
  function anyAlive(list){ for(const r of list) if(r.alive) return true; return false; }
  function anyAnimalAlive(){ for(const a of animals) if(a.state!=="Dead") return true; return false; }
  function allDone(){
    if(anyAlive(trees) || anyAlive(rocks) || anyAlive(meats) || anyAnimalAlive()) return false;
    for(const u of workers){
      if(u.dead) continue;
      if(u.carry>0) return false;
      if(u.state!=="Idle" && u.state!=="Parked" && u.state!=="QueueStorage") return false;
    }
    return true;
  }

  function tick(){
    tickCount++;

    processPathQueue();

    // animals first (so they move/attack)
    for(const a of animals) tickAnimal(a);

    // workers/scouts
    for(const s of scouts) tickScout(s);
    for(const w of workers) tickWorker(w);

    updateVisibilityAndFogLayers();

    // cleanup known lists occasionally
    if((tickCount % (TICK_HZ*3|0))===0){
      knownTreeIds = knownTreeIds.filter(id => trees[id] && trees[id].alive);
      knownRockIds = knownRockIds.filter(id => rocks[id] && rocks[id].alive);
      knownMeatIds = knownMeatIds.filter(id => meats[id] && meats[id].alive);
    }

    if(simState==="RUN" && allDone()){
      simState="DONE"; setStatus("DONE");
      log(`完成：木=${storage.wood}、礦=${storage.ore}、食物=${storage.food}`);
    }

    updateInfo();
  }

  // --- render ---
  function render(){
    if(!grid){
      ctx.fillStyle="#111"; ctx.fillRect(0,0,canvas.width,canvas.height);
      return;
    }
    ctx.clearRect(0,0,canvas.width,canvas.height);
    ctx.drawImage(baseLayer,0,0);

    // animate visible resources lightly
    for(let s=0;s<60;s++){
      const x=(Math.random()*W)|0, y=(Math.random()*H)|0;
      const i=idx(x,y);
      if(!visible[i]) continue;
      if(resType[i]===ResT.Tree){
        ctx.fillStyle="rgb(0,190,0)"; ctx.fillRect(x*TILEPX,y*TILEPX,TILEPX,TILEPX);
      } else if(resType[i]===ResT.Rock){
        ctx.fillStyle="rgb(160,80,255)"; ctx.fillRect(x*TILEPX,y*TILEPX,TILEPX,TILEPX);
      } else if(resType[i]===ResT.Meat){
        ctx.fillStyle="rgb(210,120,80)"; ctx.fillRect(x*TILEPX,y*TILEPX,TILEPX,TILEPX);
      }
    }

    // animals (visible only)
    for(const a of animals){
      if(a.state==="Dead") continue;
      const i=idx(a.x,a.y);
      if(!visible[i]) continue;
      // color: wandering = tan, chasing = red-ish, returning = gray
      if(a.state==="Chase") ctx.fillStyle="rgb(220,90,90)";
      else if(a.state==="Return") ctx.fillStyle="rgb(160,160,160)";
      else ctx.fillStyle="rgb(200,170,110)";
      ctx.fillRect(a.x*TILEPX,a.y*TILEPX,TILEPX,TILEPX);
    }

    // units (visible only)
    for(const u of units){
      if(u.dead) continue;
      const i=idx(u.x,u.y);
      if(!visible[i]) continue;
      if(u.role==="lumber") ctx.fillStyle="rgb(80,160,255)";
      else if(u.role==="miner") ctx.fillStyle="rgb(200,120,255)";
      else if(u.role==="hunter") ctx.fillStyle="rgb(100,220,160)";
      else ctx.fillStyle="rgb(255,170,70)";
      ctx.fillRect(u.x*TILEPX,u.y*TILEPX,TILEPX,TILEPX);

      // low HP indicator (tiny corner)
      const frac=u.hp/u.maxHP;
      if(frac<0.45){
        ctx.fillStyle= frac<0.2 ? "rgb(255,80,80)" : "rgb(255,210,80)";
        ctx.fillRect(u.x*TILEPX, u.y*TILEPX, Math.max(1,(TILEPX/3)|0), Math.max(1,(TILEPX/3)|0));
      }
    }

    // reservations near storage (subtle)
    for(const ti of dropTiles){
      const r=dropReservedBy[ti];
      if(r!==-1 && visible[ti]){
        ctx.fillStyle="rgba(255,255,255,0.10)";
        ctx.fillRect(xOf(ti)*TILEPX, yOf(ti)*TILEPX, TILEPX, TILEPX);
      }
    }
    for(const ti of parkTiles){
      const r=parkReservedBy[ti];
      if(r!==-1 && visible[ti]){
        ctx.fillStyle="rgba(120,190,255,0.12)";
        ctx.fillRect(xOf(ti)*TILEPX, yOf(ti)*TILEPX, TILEPX, TILEPX);
      }
    }

    // preferred outline
    if(preferred.type && preferred.id!=null){
      let rx=-1, ry=-1;
      if(preferred.type==="tree"){ const t=trees[preferred.id]; if(t&&t.alive){rx=t.x;ry=t.y;} }
      else if(preferred.type==="rock"){ const r=rocks[preferred.id]; if(r&&r.alive){rx=r.x;ry=r.y;} }
      else if(preferred.type==="meat"){ const m=meats[preferred.id]; if(m&&m.alive){rx=m.x;ry=m.y;} }
      if(rx!==-1){
        const i=idx(rx,ry);
        if(explored[i]){
          ctx.strokeStyle="rgba(255,255,255,0.9)";
          ctx.lineWidth=1;
          ctx.strokeRect(rx*TILEPX+0.5, ry*TILEPX+0.5, TILEPX-1, TILEPX-1);
        }
      }
    }

    ctx.drawImage(fogLayer,0,0);
  }

  // --- info ---
  function countAlive(list){ let c=0; for(const r of list) if(r.alive) c++; return c; }
  function countAnimalsAlive(){ let c=0; for(const a of animals) if(a.state!=="Dead") c++; return c; }
  function roleAbbr(role){
    if(role==="lumber") return "L";
    if(role==="miner") return "M";
    if(role==="hunter") return "H";
    if(role==="scout") return "S";
    return "U";
  }
  function hpBar(hp,max, w=12){
    if(max<=0) return "".padEnd(w,"░");
    const f=Math.max(0, Math.min(w, Math.round(w*hp/max)));
    return "█".repeat(f) + "░".repeat(w-f);
  }
  function padL(s,w){ s=String(s); return (s.length>=w)?s:(" ".repeat(w-s.length)+s); }
  function padR(s,w){ s=String(s); return (s.length>=w)?s:(s+" ".repeat(w-s.length)); }
  function updateInfo(){
    const aliveTrees=countAlive(trees||[]);
    const aliveRocks=countAlive(rocks||[]);
    const aliveMeats=countAlive(meats||[]);
    const aliveAnimals=countAnimalsAlive();
    const exploredCnt = explored ? explored.reduce((a,v)=>a+v,0) : 0;
    const exploredPct = Math.round(100*exploredCnt/N);

    let qDrop=0, qPark=0, fleeing=0, deadUnits=0;
    for(const w of workers){
      if(w.dead) deadUnits++;
      if(w.flee && !w.dead) fleeing++;
      if(w.state==="QueueStorage") qDrop++;
      if(w.state==="Parked" || w.state==="ToPark") qPark++;
    }

    infoEl.innerHTML = `
      <div class="kv">
        <div class="pill">狀態 <b>${simState}</b></div>
        <div class="pill">探索度 <b>${exploredPct}%</b></div>
        <div class="pill">PathQueue <b>${pathQueue.length}</b> / budget ${ASTAR_BUDGET}</div>
        <div class="pill">Park/Queue <b>${qPark}</b> / <b>${qDrop}</b></div>
        <div class="pill">逃跑中 <b>${fleeing}</b></div>
        <div class="pill">已陣亡 <b>${deadUnits}</b></div>
        <div class="pill">Tick <b>${tickCount}</b></div>
        <div style="margin-top:8px;"><b>倉庫</b>：木=<b>${storage.wood}</b>　礦=<b>${storage.ore}</b>　食物=<b>${storage.food}</b></div>
        <div><b>資源</b>：樹<b>${aliveTrees}</b> / ${trees?trees.length:0}　礦<b>${aliveRocks}</b> / ${rocks?rocks.length:0}　肉<b>${aliveMeats}</b></div>
        <div><b>動物</b>：存活<b>${aliveAnimals}</b> / ${animals?animals.length:0}</div>
        <div><b>單位</b>：總數 ${units?units.length:0}　工人/獵人 ${workers?workers.length:0}　斥侯 ${scouts?scouts.length:0}</div>
        <div><b>參數</b>：tick ${TICK_HZ}Hz　抽樣K=${SAMPLE_K}　格像素=${TILEPX}px　逃跑<20%</div>
      </div>
    `;
    if(hpAllEl){
      const rows=[];
      for(const u of units){
        if(u.dead) continue;
        const ab=roleAbbr(u.role);
        const idStr=padL(u.id,3);
        const hpStr=padL(u.hp,3)+"/"+padL(u.maxHP,3);
        rows.push(`${ab}#${idStr}  ${hpStr}  ${hpBar(u.hp,u.maxHP)}`);
      }
      hpAllEl.textContent = rows.length ? rows.join("\n") : "(無單位)";
    }
  }

  // --- UI wiring ---
  function readParams(){
    return {
      lumberCount: clampInt(inpLumber.value,0,900,60),
      minerCount: clampInt(inpMiner.value,0,900,50),
      hunterCount: clampInt(inpHunter.value,0,900,30),
      scoutCount: clampInt(inpScout.value,0,200,6),
      hpLumber: clampInt(inpHPLumber.value,1,200,10),
      hpMiner: clampInt(inpHPMiner.value,1,200,10),
      hpHunter: clampInt(inpHPHunter.value,1,200,12),
      hpScout: clampInt(inpHPScout.value,1,200,8),
      hpAnimal: clampInt(inpHPAnimal.value,1,200,18),
      treeCount: clampInt(inpTrees.value,0,9000,1200),
      rockCount: clampInt(inpRocks.value,0,6000,750),
      animalCount: clampInt(inpAnimals.value,0,3000,220),
      obsPercent: clampInt(inpObs.value,0,40,10),
      visionWorker: clampInt(inpVisW.value,2,24,7),
      visionScout: clampInt(inpVisS.value,4,36,13),
      tilePx: clampInt(inpTile.value,4,12,7),
      astarBudget: clampInt(inpAstarBudget.value,1,80,12),
      sampleK: clampInt(inpSampleK.value,5,200,45),
      tickHz: clampInt(inpHz.value,5,60,20),
    };
  }

  btnGen.onclick=()=>{
    const p=readParams();
    inpLumber.value=p.lumberCount; inpMiner.value=p.minerCount; inpHunter.value=p.hunterCount; inpScout.value=p.scoutCount;
    inpHPLumber.value=p.hpLumber; inpHPMiner.value=p.hpMiner; inpHPHunter.value=p.hpHunter; inpHPScout.value=p.hpScout; inpHPAnimal.value=p.hpAnimal;
    inpTrees.value=p.treeCount; inpRocks.value=p.rockCount; inpAnimals.value=p.animalCount; inpObs.value=p.obsPercent;
    inpVisW.value=p.visionWorker; inpVisS.value=p.visionScout; inpTile.value=p.tilePx;
    inpAstarBudget.value=p.astarBudget; inpSampleK.value=p.sampleK; inpHz.value=p.tickHz;
    generate(p);
  };

  btnStart.onclick=()=>{
    if(!grid){ log("請先按「生成地圖」。"); return; }
    if(simState==="READY"||simState==="PAUSE"){
      simState="RUN"; setStatus("RUN"); log("開始");
      try{ tick(); } catch(e){ log(`JS Error: ${e.message}`); }
    }
    else if(simState==="DONE") log("已完成，請先生成地圖再開始。");
  };
  btnPause.onclick=()=>{
    if(!grid) return;
    if(simState==="RUN"){ simState="PAUSE"; setStatus("PAUSE"); log("暫停"); }
    else if(simState==="PAUSE"){ simState="RUN"; setStatus("RUN"); log("繼續"); }
    else log("目前狀態非 RUN（READY/DONE）。");
  };
  btnStep.onclick=()=>{
    if(!grid) return;
    if(simState==="RUN"||simState==="DONE") return;
    const prev=simState;
    simState="PAUSE"; setStatus("PAUSE");
    tick();
    simState=prev; setStatus(prev);
  };

  // RAF loop
  let lastTime=performance.now();
  let acc=0;
  function raf(t){
    const dt=(t-lastTime)/1000;
    lastTime=t;
    if(simState==="RUN"){
      acc += dt;
      const step=1/TICK_HZ;
      let steps=0;
      const maxSteps=6;
      while(acc>=step && steps<maxSteps){
        tick();
        acc -= step;
        steps++;
      }
    } else acc=0;

    render();
    requestAnimationFrame(raf);
  }

  // Boot
  resizeCanvases();
  ctx.fillStyle="#111"; ctx.fillRect(0,0,canvas.width,canvas.height);
  log("v7：獵人/野生動物/血量/逃跑。先調參數→生成地圖→開始。");
  updateInfo();
  requestAnimationFrame(raf);
})();
</script>
</body>
</html>
